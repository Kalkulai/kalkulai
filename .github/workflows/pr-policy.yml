name: PR Policy

on:
  pull_request_target:
    types:
      - opened
      - reopened
      - synchronize
      - ready_for_review
      - labeled
      - unlabeled
  pull_request_review:
    types:
      - submitted
      - dismissed
  check_suite:
    types:
      - completed

permissions:
  contents: read
  pull-requests: write
  issues: write
  statuses: write
  checks: read

jobs:
  enforce:
    name: Evaluate PR readiness
    runs-on: ubuntu-latest
    steps:
      - name: Evaluate policy
        id: policy
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const eventName = context.eventName;

            /** Collect PR numbers that need evaluation */
            const prNumbers = new Set();
            if (eventName === "pull_request_target") {
              prNumbers.add(context.payload.pull_request.number);
            } else if (eventName === "pull_request_review") {
              prNumbers.add(context.payload.pull_request.number);
            } else if (eventName === "check_suite") {
              const prs = context.payload.check_suite?.pull_requests || [];
              for (const pr of prs) {
                if (pr && pr.number) {
                  prNumbers.add(pr.number);
                }
              }
            } else {
              core.info(`No handler for event ${eventName}`);
            }

            if (!prNumbers.size) {
              core.info("No pull requests to evaluate for this event.");
              return;
            }

            const allowedConclusions = new Set(["success", "neutral", "skipped"]);
            const summary = [];

            for (const number of prNumbers) {
              const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: number });
              const prState = pr.state;
              if (prState !== "open") {
                summary.push(`PR #${number}: skipped (state=${prState})`);
                continue;
              }

              const isDraft = Boolean(pr.draft);
              const labels = (pr.labels || []).map((label) => (label.name || "").toLowerCase());
              const hasReadyLabel = labels.includes("ready for merge");

              // Latest review state per user
              const { data: reviews } = await github.rest.pulls.listReviews({
                owner,
                repo,
                pull_number: number,
                per_page: 100,
              });
              const reviewerStates = new Map();
              for (const review of reviews) {
                if (!review.user || !review.user.login) continue;
                reviewerStates.set(review.user.login, review.state.toUpperCase());
              }
              const hasApproval = Array.from(reviewerStates.values()).some((state) => state === "APPROVED");

              const sha = pr.head.sha;
              const statusResp = await github.rest.repos.getCombinedStatusForRef({ owner, repo, ref: sha });
              const statuses = statusResp.data.statuses || [];
              const statusSuccess = statusResp.data.state === "success" || statuses.length === 0;

              const checksResp = await github.rest.checks.listForRef({
                owner,
                repo,
                ref: sha,
                per_page: 100,
              });
              const checkRuns = checksResp.data.check_runs || [];
              const checksAreGreen =
                checkRuns.length === 0 ||
                checkRuns.every((run) => {
                  if (run.status !== "completed") return false;
                  const conclusion = (run.conclusion || "").toLowerCase();
                  return allowedConclusions.has(conclusion);
                });

              const requirementsMet = hasApproval && statusSuccess && checksAreGreen && !isDraft;
              const statusState = requirementsMet ? "success" : "failure";
              const statusDescription = requirementsMet
                ? "Ready: >=1 Approval und alle Checks sind grün."
                : "Nicht bereit: min. 1 Approval und grüne Checks erforderlich.";

              await github.rest.repos.createCommitStatus({
                owner,
                repo,
                sha,
                state: statusState,
                context: "PR Gatekeeper",
                description: statusDescription,
                target_url: pr.html_url,
              });

              if (hasReadyLabel && !requirementsMet) {
                const missing = [];
                if (isDraft) missing.push("PR ist noch Draft");
                if (!hasApproval) missing.push("kein Approval");
                if (!statusSuccess || !checksAreGreen) missing.push("Checks nicht alle grün");

                const body = [
                  "⚠️ Diese PR wurde mit dem Label `ready for merge` markiert, erfüllt aber nicht alle Merge-Kriterien.",
                  "",
                  `Fehlende Punkte: ${missing.join(", ") || "unbekannt"}`,
                  "",
                  "Die PR wird automatisch geschlossen. Bitte behebe die Punkte und öffne anschließend eine neue PR.",
                ].join("\n");

                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: number,
                  body,
                });

                await github.rest.issues.update({
                  owner,
                  repo,
                  issue_number: number,
                  state: "closed",
                });
              }

              summary.push(
                `PR #${number}: approvals=${hasApproval} checksGreen=${checksAreGreen && statusSuccess} draft=${isDraft} readyLabel=${hasReadyLabel} -> requirementsMet=${requirementsMet}`
              );
            }

            core.setOutput("summary", summary.join("\n"));

      - name: Output summary
        run: |
          echo "${SUMMARY}"
        env:
          SUMMARY: ${{ steps.policy.outputs.summary }}

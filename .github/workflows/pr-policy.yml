name: PR Policy

on:
  pull_request_target:
    types:
      - opened
      - reopened
      - synchronize
      - ready_for_review
      - labeled
      - unlabeled
  pull_request_review:
    types:
      - submitted
      - dismissed
  check_suite:
    types:
      - completed
  workflow_run:
    workflows: ["be-ci", "smoke", "PR Policy"]  # alle relevanten Workflows hier eintragen
    types:
      - completed


permissions:
  contents: read
  pull-requests: write
  issues: write
  statuses: write
  checks: read

jobs:
  enforce:
    name: Evaluate PR readiness
    runs-on: ubuntu-latest
    steps:
      - name: Evaluate policy
        id: policy
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const eventName = context.eventName;

            const prNumbers = new Set();
            if (eventName === "pull_request_target") {
              prNumbers.add(context.payload.pull_request.number);
            } else if (eventName === "pull_request_review") {
              prNumbers.add(context.payload.pull_request.number);
            } else if (eventName === "check_suite") {
              const prs = context.payload.check_suite?.pull_requests || [];
              for (const pr of prs) {
                if (pr?.number) {
                  prNumbers.add(pr.number);
                }
              }
            }

            if (!prNumbers.size) {
              core.info("No pull requests to evaluate for this event.");
              core.setOutput("summary", "No pull requests evaluated.");
              return;
            }

            const allowedConclusions = new Set(["success", "neutral", "skipped"]);
            const summary = [];

            for (const number of prNumbers) {
              const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: number });
              if (pr.state !== "open") {
                summary.push(`PR #${number}: skipped (state=${pr.state})`);
                continue;
              }

              const isDraft = Boolean(pr.draft);
              // Reviews (latest state per reviewer)
              const reviews = await github.paginate(
                github.rest.pulls.listReviews,
                { owner, repo, pull_number: number, per_page: 100 }
              );
              const reviewerStates = new Map();
              for (const review of reviews) {
                if (!review.user?.login) continue;
                reviewerStates.set(review.user.login, (review.state || "").toUpperCase());
              }
              const hasApproval = Array.from(reviewerStates.values()).some((state) => state === "APPROVED");

              // Combined status + check runs
              const sha = pr.head.sha;
              const statusResp = await github.rest.repos.getCombinedStatusForRef({ owner, repo, ref: sha });
              const combinedState = statusResp.data.state; // success | failure | pending | error
              const statuses = statusResp.data.statuses || [];

              const checksResp = await github.rest.checks.listForRef({ owner, repo, ref: sha, per_page: 100 });
              const checkRuns = checksResp.data.check_runs || [];
              const anyPending = combinedState === "pending" || checkRuns.some((run) => run.status !== "completed");
              const checksAreGreen =
                checkRuns.length === 0 ||
                checkRuns.every((run) => {
                  if (run.status !== "completed") return false;
                  const conclusion = (run.conclusion || "").toLowerCase();
                  return allowedConclusions.has(conclusion);
                });
              const statusSuccess = combinedState === "success" || statuses.length === 0;

              const requirementsMet = hasApproval && statusSuccess && checksAreGreen && !isDraft;

              // Status-Check "PR Gatekeeper"
              let statusState;
              let statusDescription;
              if (anyPending) {
                statusState = "pending";
                statusDescription = "Checks noch pending.";
              } else if (requirementsMet) {
                statusState = "success";
                statusDescription = "Ready: ≥1 Approval und alle Checks sind grün.";
              } else {
                statusState = "failure";
                statusDescription = "Nicht bereit: min. 1 Approval und grüne Checks erforderlich.";
              }

              await github.rest.repos.createCommitStatus({
                owner,
                repo,
                sha,
                state: statusState,
                context: "PR Gatekeeper",
                description: statusDescription,
                target_url: pr.html_url,
              });

              summary.push(
                `PR #${number}: approvals=${hasApproval} checksGreen=${checksAreGreen && statusSuccess} draft=${isDraft} anyPending=${anyPending} -> requirementsMet=${requirementsMet}`
              );
            }

            core.setOutput("summary", summary.join("\n"));

      - name: Output summary
        run: |
          echo "${SUMMARY}"
        env:
          SUMMARY: ${{ steps.policy.outputs.summary }}
